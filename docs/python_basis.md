### python 基础
1. [垃圾回收](/docs/python_basis.md#垃圾回收)
   [深浅拷贝](/docs/python_basis.md#深浅拷贝)
   [闭包-装饰器](/docs/python_basis.md#闭包-装饰器)
   [迭代器-生成器](/docs/python_basis.md#迭代器-生成器)
   [静态方法-类方法-实例方法](/docs/python_basis.md#静态方法-类方法-实例方法)

2. GIL 线程 进程 协程 异步

3. 设计模式

###### 垃圾回收
引用计数为主，标记-清除和隔代回收为辅  
1. 引用计数：每个对象维护一个计数字段，引用计数为0则回收。  
   新的引用指向该对象时 +1，如：对象被创建，对象被引用，对象当作参数传入函数中，对象作为一个元素存储在容器中。  
   对象的引用失效时 -1，如：对象的别名被显式销毁，对象的别名被赋予新的对象，离开它的作用域，所在容器被销毁或者从容器中删除对象。  
   优点：简单；实时性，一旦没有引用内存直接释放。  
   缺点：维护引用计数消耗资源；会出现循环引用导致内存泄漏。  
2. 标记-清除：解决引用计数带来的循环引用的问题。  
   标记阶段：遍历所有的对象，如果还有对象引用它，则标记为可达。  
   清除阶段：再次遍历所有对象，如果没有标记为可达，则回收。  
3. 分代回收：由于上述引用计数+标记清除比较耗时，分代回收以空间换时间来提高垃圾回收效率.(gc模块)。  
   内存分为3代，第0代，第1代，第2代，对应三个链表，扫描频率逐渐降低。当扫描其中其中一代时，比它年轻的代也都会被扫描。  
   新创建的对象被分配在第0代，首先进行扫描第0代，回收该回收的，不该回收的放到第1代。  
   依此类推第2代放的是最不容易被回收的，并且第2代扫描频率最低。  

###### 深浅拷贝
其实只针对可变类型才有作用  
1. 对象的属性：存储地址(id)，类型(type)，变量名(对象地址的引用)，值。  
2. 存储地址(id)。  
   不可变类型：数值，字符串，布尔，id和值不变。  
      eg：a = 'python', b = 'python', id(a) == id(b)  
   可变类型：字典，列表，集合。值可变但是id不可变。  
      eg: a = [1], a.append(2), 前后id是同一个；  
          b = [3], c = [3], id(b) != id(c)；  
          d = [4], e = d, id(d) == id(e)   
3. 浅拷贝：只拷贝数据的最外层，不会拷贝子元素对象。  
   不可变类型：浅拷贝的对象和原对象id相同。  
   eg：a = 'python', b = copy.copy(a), id(a) == id(b)  
   可变类型：无论嵌套与否，本身的浅拷贝对象和原对象id不同，但里面子元素对象的id是相同的。  
   eg：a = [1,[2, 3]], b = copy.copy(a), id(a) != id(b), id(a[0]) == id(b[0]), id(a[1]) == id(b[1]), id(a[1][0]) == id(b[1][0])  
4. 深拷贝：拷贝所有的可变数据类型，包含嵌套的子元素对象。  
   不可变类型：与浅拷贝一样，深拷贝的对象和原对象id相同。  
   eg：a = 'python', b = copy.deepcopy(a), id(a) == id(b)  
   可变类型：所有层级的子可变类型对象都会拷贝，子不可变类型对象不拷贝。  
   eg: a = [1, [2, 3]], b = copy.deepcopy(a), id(a) != id(b), id(a[0]) == id(b[0]), id(a[1]) != id(b[1]), id(a[1][0]) == id(b[1][0])  

###### 闭包 装饰器
闭包
1. 定义：指在方法内引用方法外定义的非全局变量。内部方法使用外部方法中定义的非全局变量。  
   eg: [bi_bao_outer](/script/bibao_decorator.py)
2. 自由变量：如果一个变量在代码块中使用，但是没在代码快中定义，既未在本地作用域绑定的变量。
3. 修改变量值：如果变量值是可变的，如list，可直接进行append；如果变量值是不可变的，如int自增，需要nonlocal声明。(python2没有nonlocal，需要转变成可变类型)  
   eg: [bi_bao_nonlocal](/script/bibao_decorator.py)
装饰器
4. 定义：装饰器是闭包形式的一种实现，将函数作为一个参数，形成一个特殊的闭包。  
   eg: 耗时统计[decorator_outer](/script/bibao_decorator.py)  
   eg: 参数化装饰器，装饰器工厂函数[decorator_factory](/script/bibao_decorator.py)
5. 注意：增加@functools.wraps(func), 可以保持当前装饰器去装饰的函数的 __name__的值不变。

###### 迭代器 生成器

###### 静态方法 类方法 实例方法
